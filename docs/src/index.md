# FunctionChains.jl

FunctionChains.jl provides chained/composed functions with functionality beyond `Base.ComposedFunction`, as well as some other ways of combining functions.

The package defines the function [`fchain`](@ref) that turns a sequence of functions into a callable function chain. Functions are applied in the order they are given, so `fchain(f, g, h)` and `fchain((f, g, h))` are semantically equivalent to `h ∘ g ∘ f`.

Function chains can be based on tuples of functions but also on arrays (e.g. `fchain([x -> i * x for i in 1:4])`) or generators/iterators (e.g. `fchain((x -> i * x for i in 1:4))`) of functions. `fchain` will always try to generate type-stable function chains if possible.

The function chain generated by `fchain` supports [`InverseFunctions.inverse`](https://github.com/JuliaMath/InverseFunctions.jl) and/or [`ChangesOfVariables.with_logabsdet_jacobian`](https://github.com/JuliaMath/ChangesOfVariables.jl), as well as the [`Adapt`](https://github.com/JuliaGPU/Adapt.jl), [`Functors`](https://github.com/FluxML/Functors.jl) and [`FlexiMaps`](https://gitlab.com/aplavin/FlexiMaps.jl) APIs, if all functions in the chain do support the respective API.

[`frepeat(f, n)`](@ref) and [`f∘̂ n`](@ref) build a chain of `n` repetitions of function `f`. Use [`fcomp(f, g, h)`](@ref) to compose functions in the order `f ∘ g ∘ h`, equivalent to `fchain(h, g, f)`.

[`fcprod(fs)`](@ref) constructs a [Cartesian product of functions](https://en.wikipedia.org/wiki/Cartesian_product#Cartesian_product_of_functions).

[`ffanout(fs)`](@ref) constructs a function fanout.

FunctionChains also exports the convenience functions [`asfunction(f)`](@ref) and [`typed_callable(f)`](@ref) that wrap a callable `f` in a properly typed callable function (object) if necessary, e.g. if `f` is a type (constructor).


## Function chains

Example:

```jldoctest intro_example
using FunctionChains

f = fchain(Complex, sqrt)
f(-1)

# output

0.0 + 1.0im
```

```jldoctest intro_example
g = fchain((x -> i * x for i in 1:4))
g(1.75)

# output

42.0
```

The functions chains `f` and `g` in this example are both [type stable](https://docs.julialang.org/en/v1/manual/performance-tips/#man-code-warntype)

```jldoctest intro_example; output = false
using Test
@inferred f(-1)

# output

0.0 + 1.0im
```


```jldoctest intro_example; output = false
@inferred g(1.75)

# output

42.0
```

In general, type stability will depend on the functions in the sequence and the type of the sequence itself.


## Function products

A [Cartesian product of functions](https://en.wikipedia.org/wiki/Cartesian_product#Cartesian_product_of_functions) applies some kind of collection (a tuple, array, `NamedTuple` or an iterable in general) of functions to a collection (with the same shape) of values, in an component/element-wise fashion:

```jldoctest intro_example
fp = fcprod(x -> 2*x, x -> 3*x)
fp((4, 5))

# output

(8, 15)
```

```jldoctest intro_example
fp = fcprod((a = x -> 2*x, b = x -> 3*x))
fp((a = 4, b = 5))

# output

(a = 8, b = 15)
```


## Function fanouts

A function fanout applies some kind of collection a functions to single input, separately, resulting in a collection of the outputs:

```jldoctest intro_example
fp = ffanout([Base.Fix1(*, 2), Base.Fix1(*, 3), Base.Fix1(*, 4)])
fp(4) == [8, 12, 16]

# output

true
```

```jldoctest intro_example
fp = ffanout((a = x -> 2*x, b = x -> 3*x))
fp(4)

# output

(a = 8, b = 12)
```
