var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [FunctionChains]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#FunctionChains.FunctionChains","page":"API","title":"FunctionChains.FunctionChains","text":"module FunctionChains\n\nImplements chained functions (composed functions) beyond Base.ComposedFunction.\n\n\n\n\n\n","category":"module"},{"location":"api/#FunctionChains.AsFunction","page":"API","title":"FunctionChains.AsFunction","text":"struct FunctionChains.AsFunction{F} <: Function\n\nWraps a callable object to make it a Function.\n\nUser code should typically not instantiate AsFunction objects directly, but use asfunction(f) instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionChains.FunctionChain","page":"API","title":"FunctionChains.FunctionChain","text":"struct FunctionChain{FS}<:Function\n\nRepresents a chain of composed functions.\n\nA FunctionChain has a single field fs which may be a tuple, array or generator/iterator of functions.\n\n(chain::FunctionChain)(x) applies the functions in the cain in order of iteration over chain.fs. ```\n\nSupports with_intermediate_results. Also supports InverseFunctions.inverse and/or ChangesOfVariables.with_logabsdet_jacobian if all functions in the chain do so.\n\nUse fchain to construct function chains instead of FunctionChain(fs).\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionChains.:∘̂-Tuple{Any, Integer}","page":"API","title":"FunctionChains.:∘̂","text":"∘̂(f, n::Integer)\nf∘̂ n\n\nCreate a chain of function f repeated n times, with support for n <= 0.\n\nIf n > 0 then f∘̂ n behaves like frepeat(f, n). If n == 0 then it returns the identity function and if n < 0 then it behaves like frepeat(InverseFunctions.inverse(f), n).\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionChains.asfunction","page":"API","title":"FunctionChains.asfunction","text":"asfunction(f)::Function\nasfunction(f::Function) === f\n\nWraps a callable f to make it a Function.\n\nIf f isa Function, simply returns f. If f is A type (constructor), returns a properly typed function object.\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.fchain","page":"API","title":"FunctionChains.fchain","text":"fchain()\nfchain(fs)\n\nConstruct a function chain of functions fs.\n\nTypically returns a FunctionChain, but may be specialized to return other function chain types for specific types of functions.\n\nfs must be iterable, it may be a tuple, vector, generator, etc. fchain(fs)(x) will apply the functions in fs in order of iteration.\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.frepeat-Tuple{Any, Integer}","page":"API","title":"FunctionChains.frepeat","text":"frepeat(f, n::Integer)\n\nCreate a chain of function f repeated n times.\n\nSee also ∘̂(f, n) for a version that supports n <= 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionChains.typed_callable","page":"API","title":"FunctionChains.typed_callable","text":"typed_callable(f)\n\nWraps a callable f in a typed function object if necessary, e.g. if f is a type (constructor).\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.with_intermediate_results","page":"API","title":"FunctionChains.with_intermediate_results","text":"with_intermediate_results(f, x)\n\nApply multi-step function f to x and return a collection that contains the intermediate results and the final result.\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#FunctionChains.jl","page":"Home","title":"FunctionChains.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FunctionChains.jl implements chained functions with functionality beyond Base.ComposedFunction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package defines the function fchain that turns a sequence of functions into a callable function chain. Functions are applied in the order they are given, so fchain(f, g, h) and fchain((f, g, h)) are semantically equivalent to h ∘ g ∘ f.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Function chains can be based on tuples of functions but also on arrays (e.g. fchain([x -> i * x for i in 1:4]) or generators/iterators (e.g. fchain((x -> i * x for i in 1:4)) of functions. fchain will always try to generate type-stable function chains if possible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function chain generated by fchain supports InverseFunctions.inverse and/or ChangesOfVariables.with_logabsdet_jacobian, as well as the Adapt, Functors and FlexiMaps APIs, if all functions in the chain do support the respective API.","category":"page"},{"location":"","page":"Home","title":"Home","text":"FunctionChains also exports the convenience functions asfunction(f) and typed_callable(f) that wrap a callable f in a properly typed callable function (object) if necessary, e.g. if f is a type (constructor).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FunctionChains\n\nf = fchain(Complex, sqrt)\nf(-1)\n\n# output\n\n0.0 + 1.0im","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = fchain((x -> i * x for i in 1:4))\ng(1.75)\n\n# output\n\n42.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"The functions chains f and g in this example are both type stable","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Test\n@inferred f(-1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"@inferred g(1.75)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, type stability will depend on the functions in the sequence and the type of the sequence itself.","category":"page"}]
}
