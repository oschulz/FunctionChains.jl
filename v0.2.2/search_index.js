var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#FunctionChains.FunctionChains","page":"API","title":"FunctionChains.FunctionChains","text":"module FunctionChains\n\nImplements chained functions (composed functions) beyond Base.ComposedFunction.\n\n\n\n\n\n","category":"module"},{"location":"api/#FunctionChains.AsFunction","page":"API","title":"FunctionChains.AsFunction","text":"struct FunctionChains.AsFunction{F} <: Function\n\nWraps a callable object to make it a Function.\n\nUser code should typically not instantiate AsFunction objects directly, but use asfunction(f) instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionChains.FCartProd","page":"API","title":"FunctionChains.FCartProd","text":"struct FCartProd{FS}<:Function\n\nRepresents a Cartesian product of functions.\n\nUse`AFCartProdhas a single fieldfswhich may be aTuple,NamedTuple`, an array or a generator/iterator of functions.\n\nUse fcprod to construct products of functions instead of using the constructor FCartProd(fs) directly.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionChains.FFanout","page":"API","title":"FunctionChains.FFanout","text":"struct FFanout{FS}<:Function\n\nRepresents a function fanout.\n\nUse`AFFanouthas a single fieldfswhich may be aTuple,NamedTuple`, an array or a generator/iterator of functions.\n\nUse ffanout to construct a function fanout instead of using the constructor FFanout(fs) directly.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionChains.FunctionChain","page":"API","title":"FunctionChains.FunctionChain","text":"struct FunctionChain{FS}<:Function\n\nRepresents a chain of composed functions.\n\n(fc::FunctionChain)(x) applies the functions in the chain in order of iteration over fc._fs.\n\nUse fchain to construct function chains instead of using the constructor FunctionChain(fs) directly.\n\nUse fchainfs(fc) to retrieve the components of a FunctionChain in order of function execution.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionChains.:∘̂-Tuple{Any, Integer}","page":"API","title":"FunctionChains.:∘̂","text":"∘̂(f, n::Integer)\nf∘̂ n\n\nCreate a chain of function f repeated n times, with support for n <= 0.\n\nThe type of the returned function depends on n:\n\nn == 0: return identity\nn == 1: return f\nn > 1: return frepeat(f, n)\nn == -1: return InverseFunctions.inverse(f)\nn > -1: return frepeat(InverseFunctions.inverse(f), -n)\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionChains.applyf","page":"API","title":"FunctionChains.applyf","text":"applyf(f, xs...) = f(xs...)\n\nFunction application: Apply a function f to one or multiple arguments.\n\nPrimarily useful to broadcast collections of function over collections of arguments, e.g. applyf(fs, as, bs, ...) or to calculate derivatives in respect to function parameters (closure contents), e.g. Zygote.gradient(applyf, f_withargs, xs...).\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.asfunction","page":"API","title":"FunctionChains.asfunction","text":"asfunction(f)::Function\nasfunction(f::Function) === f\n\nWraps a callable f to make it a Function.\n\nIf f isa Function, simply returns f. If f is A type (constructor), returns a properly typed function object.\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.fbcast","page":"API","title":"FunctionChains.fbcast","text":"fbcast(f)\n\nReturn a broadcasted version of the function f, so that fbcast(f)(A, ...) is semantically equivalent to f.(A, ...).\n\nfbcast(f)(A) is also semantically equivalent to fcprod( Fill(f, size(A)) )(A).\n\nTypically returns a Broadcast.BroadcastFunction, but may be specialized to return broadcasted implementations depending on the type of f. For example, fbcast(identity) === identity.\n\nThe resulting broadcasted function supports InverseFunctions.inverse and/or ChangesOfVariables.with_logabsdet_jacobian if f does so.\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.fchain","page":"API","title":"FunctionChains.fchain","text":"fchain()\nfchain(fs)\nfchain(fs...)\n\nConstruct a function chain of functions fs.\n\nTypically returns a FunctionChain, but may be specialized to return other function chain types for specific types of functions.\n\nfs must be iterable, it may be a tuple, vector, generator, etc. fchain(fs)(x) will apply the functions in fs in order of iteration.\n\nThe resulting function chain supports with_intermediate_results, and also supports InverseFunctions.inverse and/or ChangesOfVariables.with_logabsdet_jacobian if all functions in the chain do so.\n\nUse fchainfs(fc) to retrieve fs.\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.fchainfs","page":"API","title":"FunctionChains.fchainfs","text":"fchainfs(fc)\n\nGet the component functions of a function chain or composed function fc, in order of function execution.\n\nSee fchain for details.\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.fcomp","page":"API","title":"FunctionChains.fcomp","text":"fcomp()\nfcomp(fs)\nfcomp(fs...)\n\nConstruct a composition of the functions fs that is semantically equivalent to fs[1] ∘ fs[2] ∘ ... and fchain(reverse(fs)).\n\nThe resulting function composition supports with_intermediate_results, but note that the intermediate results are in order of function evaluation, not in the order of the functions in fs.\n\nThe composition also supports InverseFunctions.inverse and/or ChangesOfVariables.with_logabsdet_jacobian if all functions in the composition do so.\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.fcprod","page":"API","title":"FunctionChains.fcprod","text":"fcprod()\nfcprod(fs)\nfcprod(fs...)\n\nConstruct the Cartesian product of functions over the functions fs.\n\nTypically returns a FCartProd, but may be specialized to return other product function types for specific types of element functions.\n\nfs must be iterable, it may be a Tuple, NamedTuple, an array or a generator/iterator of functions.\n\nfcprod behaves like\n\nfcprod((f_a, f_b, ...))((x_a, x_b, ...)) = (f_a(x_a), f_b(x_b), ...)\nfcprod((a = f_a, b = f_b, ...))((a = x_a, b = x_b, ...)) = (a = f_a(x_a), b = f_b(x_b), ...)\nfcprod([f_a, f_b, ...])([x_a, x_b, ...]) = [f_a(x_a), f_b(x_b, ...)]\n\nThis is similar, semantically, to Haskell's *** for arrows.\n\nFor fp = fcprod(fs), use fcprodfs(fp) to retrieve fs.\n\nThe resulting product of functions supports InverseFunctions.inverse and/or ChangesOfVariables.with_logabsdet_jacobian if all functions in the product do so.\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.fcprodfs","page":"API","title":"FunctionChains.fcprodfs","text":"fcprodfs(fp)\n\nGet the component functions of a cartesian product of functions.\n\nSee fcprod for details.\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.ffanout","page":"API","title":"FunctionChains.ffanout","text":"ffanout()\nffanout(fs)\nffanout(fs...)\n\nConstruct a function fanout with the functions fs.\n\nThis is similar, semantically, to Haskell's &&& for arrows.\n\nTypically returns a FFanout, but may be specialized to return other function fanout types for specific types of element functions.\n\nfs must be iterable, it may be a Tuple, NamedTuple, an array or a generator/iterator of functions.\n\nThe resulting function fanout behaves like\n\nffanout((f_a, f_b, ...))(x) = (f_a(x), f_b(x), ...)\nffanout((a = f_a, b = f_b, ...))(x) = (a = f_a(x), b = f_b(x), ...)\nffanout([f_a, f_b, ...])(x) = [f_a(x), f_b(x, ...)]\n\nFor ff = ffanout(fs), use ffanoutfs(fc) to retrieve fs.\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.ffanoutfs","page":"API","title":"FunctionChains.ffanoutfs","text":"ffanoutfs(fc)\n\nGet the component functions of a function fanout.\n\nSee ffanout for details.\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.ffchain","page":"API","title":"FunctionChains.ffchain","text":"ffchain(f, g, hs...)\nffchain() = identity\nffchain(f) = f\nffchain(::Type{F}) where F = FunctionChains.AsFunction{Type{F}}(F)\n\nSimilar to fchain((f, g, hs...)), but flattens arguments of type ComposedFunction and merges FunctionChain arguments.\n\nTries to remove superfluous identity functions and to return a simple function instead of a FunctionChain if possible.\n\nBehaves like ffcomp(hs..., g, f) (see ffcomp).\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.ffcomp","page":"API","title":"FunctionChains.ffcomp","text":"ffcomp(f, g, hs...)\nffcomp() = identity\nffcomp(f) = f\nffcomp(::Type{F}) where F = FunctionChains.AsFunction{Type{F}}(F)\n\nSimilar to fcomp((f, g, hs...)), but flattens arguments of type ComposedFunction and merges FunctionChain arguments.\n\nTries to remove superfluous identity functions and to return a simple function instead of a FunctionChain if possible.\n\nBehaves like ffchain(hs..., g, f) (see ffchain).\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.frepeat","page":"API","title":"FunctionChains.frepeat","text":"frepeat(f, n::Integer)\n\nCreate a chain of function f repeated n times.\n\nSee also ∘̂(f, n) for a version that supports n <= 0.\n\nThe resulting function chain supports InverseFunctions.inverse and/or ChangesOfVariables.with_logabsdet_jacobian if f does so.\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.typed_callable","page":"API","title":"FunctionChains.typed_callable","text":"typed_callable(f)\n\nWraps a callable f in a typed function object if necessary, e.g. if f is a type (constructor).\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionChains.with_intermediate_results","page":"API","title":"FunctionChains.with_intermediate_results","text":"with_intermediate_results(f, x)\n\nApply multi-step function f to x and return a collection that contains the intermediate results and the final result.\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#FunctionChains.jl","page":"Home","title":"FunctionChains.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FunctionChains.jl provides chained/composed functions with functionality beyond Base.ComposedFunction, as well as some other ways of combining functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package defines the function fchain that turns a sequence of functions into a callable function chain. Functions are applied in the order they are given, so fchain(f, g, h) and fchain((f, g, h)) are semantically equivalent to h ∘ g ∘ f.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Function chains can be based on tuples of functions but also on arrays (e.g. fchain([x -> i * x for i in 1:4])) or generators/iterators (e.g. fchain((x -> i * x for i in 1:4))) of functions. fchain will always try to generate type-stable function chains if possible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function chain generated by fchain supports InverseFunctions.inverse and/or ChangesOfVariables.with_logabsdet_jacobian, as well as the Adapt, Functors and FlexiMaps APIs, if all functions in the chain do support the respective API.","category":"page"},{"location":"","page":"Home","title":"Home","text":"frepeat(f, n) and f∘̂ n build a chain of n repetitions of function f. Use fcomp(f, g, h) to compose functions in the order f ∘ g ∘ h, equivalent to fchain(h, g, f).","category":"page"},{"location":"","page":"Home","title":"Home","text":"ffchain(f, g, h) and ffcomp(f, g, h) behave similar to fchain(f, g, h) and fcomp(f, g, h), but flatten and merge their arguments.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fcprod(fs) constructs a Cartesian product of functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ffanout(fs) constructs a function fanout.","category":"page"},{"location":"","page":"Home","title":"Home","text":"FunctionChains also exports the convenience functions asfunction(f) and typed_callable(f) that wrap a callable f in a properly typed callable function (object) if necessary, e.g. if f is a type (constructor).","category":"page"},{"location":"#Function-chains","page":"Home","title":"Function chains","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FunctionChains\n\nf = fchain(Complex, sqrt)\nf(-1)\n\n# output\n\n0.0 + 1.0im","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = fchain((x -> i * x for i in 1:4))\ng(1.75)\n\n# output\n\n42.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"The functions chains f and g in this example are both type stable","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Test\n@inferred f(-1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"@inferred g(1.75)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, type stability will depend on the functions in the sequence and the type of the sequence itself.","category":"page"},{"location":"#Function-products","page":"Home","title":"Function products","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Cartesian product of functions applies some kind of collection (a tuple, array, NamedTuple or an iterable in general) of functions to a collection (with the same shape) of values, in an component/element-wise fashion:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fp = fcprod(x -> 2*x, x -> 3*x)\nfp((4, 5))\n\n# output\n\n(8, 15)","category":"page"},{"location":"","page":"Home","title":"Home","text":"fp = fcprod((a = x -> 2*x, b = x -> 3*x))\nfp((a = 4, b = 5))\n\n# output\n\n(a = 8, b = 15)","category":"page"},{"location":"#Function-fanouts","page":"Home","title":"Function fanouts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A function fanout applies some kind of collection a functions to single input, separately, resulting in a collection of the outputs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fp = ffanout([Base.Fix1(*, 2), Base.Fix1(*, 3), Base.Fix1(*, 4)])\nfp(4) == [8, 12, 16]\n\n# output\n\ntrue","category":"page"},{"location":"","page":"Home","title":"Home","text":"fp = ffanout((a = x -> 2*x, b = x -> 3*x))\nfp(4)\n\n# output\n\n(a = 8, b = 12)","category":"page"}]
}
